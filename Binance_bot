# Binance_Kucoin_OKX_Bot.py

import os
import logging
import time
import numpy as np
import pandas as pd
import threading
import asyncio
import requests
import torch
import torch.nn as nn
import torch.optim as optim
import websockets
from dotenv import load_dotenv
from binance.client import Client
from kucoin.client import Client as KucoinClient
from google.colab import auth
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from web3 import Web3

# 📌 API Anahtarlarını Güvenli Şekilde Yükle
load_dotenv()
BINANCE_API_KEY = os.getenv("BINANCE_API_KEY")
BINANCE_API_SECRET = os.getenv("BINANCE_API_SECRET")
KUCOIN_API_KEY = os.getenv("KUCOIN_API_KEY")
KUCOIN_API_SECRET = os.getenv("KUCOIN_API_SECRET")
OKX_API_KEY = os.getenv("OKX_API_KEY")
OKX_API_SECRET = os.getenv("OKX_API_SECRET")
ALCHEMY_ETH_API_KEY = os.getenv("ALCHEMY_ETH_API_KEY")

# 📌 Binance, KuCoin ve OKX Bağlantıları
binance_client = Client(BINANCE_API_KEY, BINANCE_API_SECRET)
kucoin_client = KucoinClient(KUCOIN_API_KEY, KUCOIN_API_SECRET)
okx_client = None  # OKX API bağlantısı burada yapılabilir

# 📌 Ethereum Blockchain Bağlantısı (Alchemy API)
w3 = Web3(Web3.HTTPProvider(f"https://eth-mainnet.g.alchemy.com/v2/{ALCHEMY_ETH_API_KEY}"))

# 📌 Google Drive Kimlik Doğrulama
auth.authenticate_user()
drive_service = build('drive', 'v3')

# 📌 Google Drive'a Veri Kaydetme
def save_to_drive(content, filename="trading_data.txt"):
    filepath = f"/content/{filename}"
    with open(filepath, "w") as file:
        file.write(content)
    file_metadata = {'name': filename, 'parents': ['binance_pump']}
    media = MediaFileUpload(filepath, mimetype='text/plain')
    file = drive_service.files().create(body=file_metadata, media_body=media, fields='id').execute()
    logging.info(f"📁 {filename} Google Drive'a kaydedildi.")

# 📌 AI Modeli (LSTM)
class LSTMPredictor(nn.Module):
    def __init__(self, input_size=1, hidden_layer_size=50, output_size=1):
        super().__init__()
        self.hidden_layer_size = hidden_layer_size
        self.lstm = nn.LSTM(input_size, hidden_layer_size, batch_first=True)
        self.linear = nn.Linear(hidden_layer_size, output_size)

    def forward(self, input_seq):
        lstm_out, _ = self.lstm(input_seq)
        predictions = self.linear(lstm_out[:, -1])
        return predictions

# 📌 AI Modelini Eğitme
def train_ai_model():
    data = pd.read_csv("market_data.csv")
    X = torch.tensor(data['feature'].values, dtype=torch.float32)
    y = torch.tensor(data['target'].values, dtype=torch.float32)

    model = LSTMPredictor()
    optimizer = optim.Adam(model.parameters(), lr=0.001)
    loss_function = nn.MSELoss()

    for epoch in range(10):
        optimizer.zero_grad()
        output = model(X)
        loss = loss_function(output, y)
        loss.backward()
        optimizer.step()

    torch.save(model.state_dict(), "ai_model.pth")
    save_to_drive("AI Modeli Güncellendi", "ai_model_log.txt")
    return model

# 📌 Haftalık ve Dinamik Model Güncelleme
def weekly_model_update():
    while True:
        logging.info("📢 Haftalık AI Model Güncellemesi Başlatıldı...")
        train_ai_model()
        logging.info("✅ AI Modeli Güncellendi!")
        time.sleep(604800)

def dynamic_model_update():
    while True:
        pnl = np.random.uniform(-10, 10)
        volatility = np.random.uniform(0.01, 0.1)
        if abs(pnl) > 5 or volatility > 0.05:
            logging.info("📢 Dinamik AI Model Güncellemesi Başlatıldı...")
            train_ai_model()
            logging.info("✅ AI Modeli Dinamik Olarak Güncellendi!")
        time.sleep(3600)

# 📌 Binance Order Book Analizi
def get_order_flow(symbol):
    order_book = binance_client.get_order_book(symbol=symbol, limit=100)
    bid_volumes = np.array([float(order[1]) for order in order_book["bids"]])
    ask_volumes = np.array([float(order[1]) for order in order_book["asks"]])
    bid_total = np.sum(bid_volumes)
    ask_total = np.sum(ask_volumes)
    order_flow_imbalance = (bid_total - ask_total) / (bid_total + ask_total)
    return order_flow_imbalance

# 📌 WebSocket Bağlantısı Başlatma
async def websocket_listener(exchange, symbol):
    uri = f"wss://stream.binance.com:9443/ws/{symbol.lower()}@trade" if exchange == "binance" else ""
    async with websockets.connect(uri) as websocket:
        while True:
            message = await websocket.recv()
            print(f"📡 {exchange.upper()} | {symbol}: {message}")

# 📌 Telegram Uyarı Sistemi
def send_telegram_alert(message):
    TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    data = {"chat_id": TELEGRAM_CHAT_ID, "text": message}
    requests.post(url, data=data)

# 📌 Anomali Tespiti
def detect_price_anomaly(prices, threshold=3):
    mean_price = np.mean(prices)
    std_price = np.std(prices)
    z_scores = [(price - mean_price) / std_price for price in prices]
    anomalies = [prices[i] for i in range(len(prices)) if abs(z_scores[i]) > threshold]
    return anomalies

# 📌 Çoklu İşlem Açma (KuCoin & OKX)
def send_order(symbol, side, quantity, price, exchange):
    api_url = "https://api.kucoin.com/api/v1/orders" if exchange == "kucoin" else "https://www.okx.com/api/v5/trade/order"
    order_data = {"symbol": symbol, "side": side, "quantity": quantity, "price": price}
    response = requests.post(api_url, json=order_data)
    return response.json()

# 📌 İşlem Yönetimi
def ultra_fast_execution():
    def execute_trade():
        print("✅ Ultra hızlı işlem açıldı!")

    threads = []
    for _ in range(4):
        thread = threading.Thread(target=execute_trade)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

# 📌 Ana Çalıştırma
if __name__ == "__main__":
    threading.Thread(target=weekly_model_update, daemon=True).start()
    threading.Thread(target=dynamic_model_update, daemon=True).start()

    symbols = ["BTCUSDT", "ETHUSDT"]
    for symbol in symbols:
        threading.Thread(target=lambda: asyncio.run(websocket_listener("binance", symbol)), daemon=True).start()

    ultra_fast_execution()
