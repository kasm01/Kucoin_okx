# Binance_Kucoin_OKX_Bot.py

import os
import logging
import time
import numpy as np
import pandas as pd
import threading
import asyncio
import requests
import torch
import torch.nn as nn
import torch.optim as optim
import websockets
from dotenv import load_dotenv
from binance.client import Client
from kucoin.client import Client as KucoinClient
from google.colab import auth
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from web3 import Web3

# ğŸ“Œ API AnahtarlarÄ±nÄ± GÃ¼venli Åekilde YÃ¼kle
load_dotenv()
BINANCE_API_KEY = os.getenv("BINANCE_API_KEY")
BINANCE_API_SECRET = os.getenv("BINANCE_API_SECRET")
KUCOIN_API_KEY = os.getenv("KUCOIN_API_KEY")
KUCOIN_API_SECRET = os.getenv("KUCOIN_API_SECRET")
OKX_API_KEY = os.getenv("OKX_API_KEY")
OKX_API_SECRET = os.getenv("OKX_API_SECRET")
ALCHEMY_ETH_API_KEY = os.getenv("ALCHEMY_ETH_API_KEY")

# ğŸ“Œ Binance, KuCoin ve OKX BaÄŸlantÄ±larÄ±
binance_client = Client(BINANCE_API_KEY, BINANCE_API_SECRET)
kucoin_client = KucoinClient(KUCOIN_API_KEY, KUCOIN_API_SECRET)
okx_client = None  # OKX API baÄŸlantÄ±sÄ± burada yapÄ±labilir

# ğŸ“Œ Ethereum Blockchain BaÄŸlantÄ±sÄ± (Alchemy API)
w3 = Web3(Web3.HTTPProvider(f"https://eth-mainnet.g.alchemy.com/v2/{ALCHEMY_ETH_API_KEY}"))

# ğŸ“Œ Google Drive Kimlik DoÄŸrulama
auth.authenticate_user()
drive_service = build('drive', 'v3')

# ğŸ“Œ Google Drive'a Veri Kaydetme
def save_to_drive(content, filename="trading_data.txt"):
    filepath = f"/content/{filename}"
    with open(filepath, "w") as file:
        file.write(content)
    file_metadata = {'name': filename, 'parents': ['binance_pump']}
    media = MediaFileUpload(filepath, mimetype='text/plain')
    file = drive_service.files().create(body=file_metadata, media_body=media, fields='id').execute()
    logging.info(f"ğŸ“ {filename} Google Drive'a kaydedildi.")

# ğŸ“Œ AI Modeli (LSTM)
class LSTMPredictor(nn.Module):
    def __init__(self, input_size=1, hidden_layer_size=50, output_size=1):
        super().__init__()
        self.hidden_layer_size = hidden_layer_size
        self.lstm = nn.LSTM(input_size, hidden_layer_size, batch_first=True)
        self.linear = nn.Linear(hidden_layer_size, output_size)

    def forward(self, input_seq):
        lstm_out, _ = self.lstm(input_seq)
        predictions = self.linear(lstm_out[:, -1])
        return predictions

# ğŸ“Œ AI Modelini EÄŸitme
def train_ai_model():
    data = pd.read_csv("market_data.csv")
    X = torch.tensor(data['feature'].values, dtype=torch.float32)
    y = torch.tensor(data['target'].values, dtype=torch.float32)

    model = LSTMPredictor()
    optimizer = optim.Adam(model.parameters(), lr=0.001)
    loss_function = nn.MSELoss()

    for epoch in range(10):
        optimizer.zero_grad()
        output = model(X)
        loss = loss_function(output, y)
        loss.backward()
        optimizer.step()

    torch.save(model.state_dict(), "ai_model.pth")
    save_to_drive("AI Modeli GÃ¼ncellendi", "ai_model_log.txt")
    return model

# ğŸ“Œ HaftalÄ±k ve Dinamik Model GÃ¼ncelleme
def weekly_model_update():
    while True:
        logging.info("ğŸ“¢ HaftalÄ±k AI Model GÃ¼ncellemesi BaÅŸlatÄ±ldÄ±...")
        train_ai_model()
        logging.info("âœ… AI Modeli GÃ¼ncellendi!")
        time.sleep(604800)

def dynamic_model_update():
    while True:
        pnl = np.random.uniform(-10, 10)
        volatility = np.random.uniform(0.01, 0.1)
        if abs(pnl) > 5 or volatility > 0.05:
            logging.info("ğŸ“¢ Dinamik AI Model GÃ¼ncellemesi BaÅŸlatÄ±ldÄ±...")
            train_ai_model()
            logging.info("âœ… AI Modeli Dinamik Olarak GÃ¼ncellendi!")
        time.sleep(3600)

# ğŸ“Œ Binance Order Book Analizi
def get_order_flow(symbol):
    order_book = binance_client.get_order_book(symbol=symbol, limit=100)
    bid_volumes = np.array([float(order[1]) for order in order_book["bids"]])
    ask_volumes = np.array([float(order[1]) for order in order_book["asks"]])
    bid_total = np.sum(bid_volumes)
    ask_total = np.sum(ask_volumes)
    order_flow_imbalance = (bid_total - ask_total) / (bid_total + ask_total)
    return order_flow_imbalance

# ğŸ“Œ WebSocket BaÄŸlantÄ±sÄ± BaÅŸlatma
async def websocket_listener(exchange, symbol):
    uri = f"wss://stream.binance.com:9443/ws/{symbol.lower()}@trade" if exchange == "binance" else ""
    async with websockets.connect(uri) as websocket:
        while True:
            message = await websocket.recv()
            print(f"ğŸ“¡ {exchange.upper()} | {symbol}: {message}")

# ğŸ“Œ Telegram UyarÄ± Sistemi
def send_telegram_alert(message):
    TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    data = {"chat_id": TELEGRAM_CHAT_ID, "text": message}
    requests.post(url, data=data)

# ğŸ“Œ Anomali Tespiti
def detect_price_anomaly(prices, threshold=3):
    mean_price = np.mean(prices)
    std_price = np.std(prices)
    z_scores = [(price - mean_price) / std_price for price in prices]
    anomalies = [prices[i] for i in range(len(prices)) if abs(z_scores[i]) > threshold]
    return anomalies

# ğŸ“Œ Ã‡oklu Ä°ÅŸlem AÃ§ma (KuCoin & OKX)
def send_order(symbol, side, quantity, price, exchange):
    api_url = "https://api.kucoin.com/api/v1/orders" if exchange == "kucoin" else "https://www.okx.com/api/v5/trade/order"
    order_data = {"symbol": symbol, "side": side, "quantity": quantity, "price": price}
    response = requests.post(api_url, json=order_data)
    return response.json()

# ğŸ“Œ Ä°ÅŸlem YÃ¶netimi
def ultra_fast_execution():
    def execute_trade():
        print("âœ… Ultra hÄ±zlÄ± iÅŸlem aÃ§Ä±ldÄ±!")

    threads = []
    for _ in range(4):
        thread = threading.Thread(target=execute_trade)
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

# ğŸ“Œ Ana Ã‡alÄ±ÅŸtÄ±rma
if __name__ == "__main__":
    threading.Thread(target=weekly_model_update, daemon=True).start()
    threading.Thread(target=dynamic_model_update, daemon=True).start()

    symbols = ["BTCUSDT", "ETHUSDT"]
    for symbol in symbols:
        threading.Thread(target=lambda: asyncio.run(websocket_listener("binance", symbol)), daemon=True).start()

    ultra_fast_execution()
